package org.opentrackingtools.updater;

import gov.sandia.cognition.math.matrix.MatrixFactory;
import gov.sandia.cognition.math.matrix.Vector;
import gov.sandia.cognition.math.matrix.VectorEntry;
import gov.sandia.cognition.math.matrix.mtj.DenseMatrix;
import gov.sandia.cognition.statistics.DataDistribution;
import gov.sandia.cognition.statistics.bayesian.ParticleFilter;
import gov.sandia.cognition.statistics.distribution.MultivariateGaussian;
import gov.sandia.cognition.util.AbstractCloneableSerializable;

import java.lang.reflect.InvocationTargetException;
import java.util.Collection;
import java.util.List;
import java.util.Random;
import java.util.Set;

import javax.annotation.Nullable;

import org.apache.commons.lang.NotImplementedException;
import org.opentrackingtools.VehicleStateInitialParameters;
import org.opentrackingtools.distributions.OnOffEdgeTransDistribution;
import org.opentrackingtools.distributions.PathStateDistribution;
import org.opentrackingtools.estimators.MotionStateEstimatorPredictor;
import org.opentrackingtools.estimators.OnOffEdgeTransitionEstimatorPredictor;
import org.opentrackingtools.graph.InferenceGraph;
import org.opentrackingtools.graph.InferenceGraphEdge;
import org.opentrackingtools.model.GpsObservation;
import org.opentrackingtools.model.VehicleState;
import org.opentrackingtools.paths.Path;
import org.opentrackingtools.paths.PathEdge;
import org.opentrackingtools.paths.PathState;
import org.opentrackingtools.util.GeoUtils;
import org.opentrackingtools.util.StatisticsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.vividsolutions.jts.geom.Envelope;

/**
 * This is an updater that produces new states from paths
 * generated by sampling edges along the predicted motion state.
 * 
 * @author bwillard
 *
 * @param <O>
 */
public class VehicleTrackingBootstrapUpdater<O extends GpsObservation>
    extends VehicleTrackingPLFilterUpdater<O> {

  private static final long serialVersionUID =
      2884138088944317656L;
  
  protected static final long maxGraphBoundsResampleTries = (long) 1e6;

  private static final Logger _log = LoggerFactory
      .getLogger(VehicleTrackingBootstrapUpdater.class);
  
  protected InferenceGraph inferenceGraph;

  protected O initialObservation;

  protected VehicleStateInitialParameters parameters;

  protected Random random;

  public long seed;

  protected PathEdge<?> nullPathEdge = new PathEdge<InferenceGraphEdge>();

  
  public VehicleTrackingBootstrapUpdater(
      O obs,
      InferenceGraph inferredGraph,
      VehicleStateInitialParameters parameters,
      Random rng) {
    super(obs, inferredGraph, parameters, rng);
  }

  @Override
  public VehicleState<O>
      update(VehicleState<O> previousState) {
    
    final VehicleState<O> updatedState = new VehicleState<O>(previousState);
    MotionStateEstimatorPredictor motionStatePredictor = new MotionStateEstimatorPredictor(
        updatedState, random, null);
    
    MultivariateGaussian predictedMotionState = motionStatePredictor.createPredictiveDistribution(
        updatedState.getMotionStateParam().getParameterPrior());
    updatedState.getMotionStateParam().setParameterPrior(predictedMotionState);
    
    List<PathEdge<?>> edges = Lists.newArrayList();
    final boolean isBackward = predictedMotionState.getInputDimensionality() == 4
        || predictedMotionState.getMean().getElement(0) >= 0d ? false : true;
    PathEdge<?> prevEdge = updatedState.getPathStateParam().getValue().getEdge();
    double distance = (isBackward ? 1d : -1d) * prevEdge.getLength();
    OnOffEdgeTransDistribution edgeTransDistribution = updatedState.getEdgeTransitionParam()
          .getConditionalDistribution();
    do {
      /*
       * When we've already started an on-road path we don't 
       * go off-road.  At least not yet.
       * To accomplish this, we perform a little hack and
       * remove the off-road state from the possible transitions.
       */
      if (!edges.isEmpty() && !prevEdge.isNullEdge()) {
        edgeTransDistribution.getDomain().remove(nullPathEdge);
      }
      InferenceGraphEdge newEdge = edgeTransDistribution.sample(random);
      
      if (!newEdge.isNullEdge()) {
        final double newDistance = distance + prevEdge.getLength();
        prevEdge = new PathEdge<InferenceGraphEdge>(newEdge, 
            newDistance, isBackward);
      } else {
        prevEdge = nullPathEdge; 
      }
      edges.add(prevEdge);
      
    } while (!prevEdge.isNullEdge() && !prevEdge.isOnEdge(
        predictedMotionState.getMean().getElement(0)));
    
    final Path newPath = new Path(edges, false);
    
    final PathState newPathState = new PathState(newPath, predictedMotionState.getMean());
    
    updatedState.getPathStateParam().setValue(newPathState);
    updatedState.setParentState(previousState);
    
    return updatedState;
  }


}