package org.opentrackingtools.updater;

import gov.sandia.cognition.math.matrix.Vector;
import gov.sandia.cognition.statistics.DataDistribution;
import gov.sandia.cognition.statistics.bayesian.ParticleFilter.Updater;
import gov.sandia.cognition.statistics.distribution.MultivariateGaussian;
import gov.sandia.cognition.util.AbstractCloneableSerializable;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Random;

import org.opentrackingtools.VehicleStateInitialParameters;
import org.opentrackingtools.distributions.CountedDataDistribution;
import org.opentrackingtools.distributions.OnOffEdgeTransDistribution;
import org.opentrackingtools.distributions.PathStateDistribution;
import org.opentrackingtools.distributions.PathStateMixtureDensityModel;
import org.opentrackingtools.estimators.MotionStateEstimatorPredictor;
import org.opentrackingtools.graph.InferenceGraph;
import org.opentrackingtools.graph.InferenceGraphEdge;
import org.opentrackingtools.graph.InferenceGraphSegment;
import org.opentrackingtools.model.GpsObservation;
import org.opentrackingtools.model.SimpleBayesianParameter;
import org.opentrackingtools.model.VehicleState;
import org.opentrackingtools.paths.Path;
import org.opentrackingtools.paths.PathEdge;
import org.opentrackingtools.paths.PathState;
import org.opentrackingtools.util.GeoUtils;
import org.opentrackingtools.util.PathUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.base.Preconditions;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.vividsolutions.jts.geom.LineSegment;

/**
 * This is an updater that produces new states from paths generated by sampling
 * edges along the predicted motion state.
 * 
 * @author bwillard
 * 
 * @param <O>
 */
public class VehicleTrackingBootstrapUpdater<O extends GpsObservation>
    extends AbstractCloneableSerializable implements
    Updater<O, VehicleState<O>> {

  private static final Logger _log = LoggerFactory
      .getLogger(VehicleTrackingBootstrapUpdater.class);

  protected static final long maxGraphBoundsResampleTries =
      (long) 1e6;

  private static final long serialVersionUID = 2884138088944317656L;

  protected InferenceGraph inferenceGraph;

  protected O initialObservation;

  protected VehicleStateInitialParameters parameters;

  protected Random random;

  public long seed;

  public VehicleTrackingBootstrapUpdater(O obs,
    InferenceGraph inferredGraph,
    VehicleStateInitialParameters parameters, Random rng) {
    this.initialObservation = obs;
    this.inferenceGraph = inferredGraph;
    if (rng == null) {
      this.random = new Random();
    } else {
      this.random = rng;
    }
    this.parameters = parameters;
  }

  @Override
  public double computeLogLikelihood(VehicleState<O> particle,
    O observation) {
    double logLikelihood = 0d;
    logLikelihood +=
        particle.getMotionStateParam().getConditionalDistribution()
            .getProbabilityFunction()
            .logEvaluate(observation.getProjectedPoint());
    return logLikelihood;
  }

  /**
   * Create vehicle states from the nearby edges.
   */
  @Override
  public DataDistribution<VehicleState<O>> createInitialParticles(
    int numParticles) {
    final DataDistribution<VehicleState<O>> retDist =
        new CountedDataDistribution<VehicleState<O>>(true);

    /*
     * Start by creating an off-road vehicle state with which we can obtain the surrounding
     * edges.
     */
    final VehicleState<O> nullState =
        VehicleState.constructInitialVehicleState(this.parameters, this.inferenceGraph, this.initialObservation, this.random,
            PathEdge.nullPathEdge);
    final MultivariateGaussian initialMotionStateDist =
        nullState.getMotionStateParam().getParameterPrior();
    final Collection<InferenceGraphSegment> edges =
        this.inferenceGraph.getNearbyEdges(initialMotionStateDist,
            initialMotionStateDist.getCovariance());

    for (int i = 0; i < numParticles; i++) {
      /*
       * From the surrounding edges, we create states on those edges.
       */
      final DataDistribution<VehicleState<O>> statesOnEdgeDistribution =
          new CountedDataDistribution<VehicleState<O>>(true);
      
      final double nullLogLikelihood =
          nullState.getEdgeTransitionParam()
              .getConditionalDistribution()
              .getProbabilityFunction().logEvaluate(InferenceGraphEdge.nullGraphEdge)
              + this.computeLogLikelihood(nullState,
                  this.initialObservation);

      statesOnEdgeDistribution
          .increment(nullState, nullLogLikelihood);

      for (final InferenceGraphSegment line : edges) {
        
        PathEdge startPathEdge = new PathEdge(line, 0d, false); 
        VehicleState<O> stateOnEdge = VehicleState.constructInitialVehicleState(
            parameters, inferenceGraph, initialObservation, random, startPathEdge);

        final double logLikelihood =
            stateOnEdge.getEdgeTransitionParam()
                .getConditionalDistribution()
                .getProbabilityFunction().logEvaluate(startPathEdge.getInferenceGraphEdge())
                + this.computeLogLikelihood(stateOnEdge,
                    this.initialObservation);

        statesOnEdgeDistribution
            .increment(stateOnEdge, logLikelihood);
      }

      retDist.increment(statesOnEdgeDistribution.sample(this.random));
    }

    return retDist;
  }

  private void getSegmentsUpToLength(InferenceGraphEdge startEdge, double lengthToTravel, List<InferenceGraphSegment> edges) {
    if (startEdge.getLength() < lengthToTravel
        && lengthToTravel > 0d) {
      Collection<InferenceGraphEdge> transferEdges = this.inferenceGraph.
          getOutgoingTransferableEdges(startEdge);
      final InferenceGraphEdge newEdge;
      if (transferEdges.size() > 1) {
        newEdge = Iterables.get(transferEdges, this.random.nextInt(transferEdges.size() - 1));
      } else if (transferEdges.size() == 1) {
        newEdge = Iterables.getOnlyElement(transferEdges);
      } else {
        // TODO what to do when there's no transfer edge?
        return;
      }
      edges.addAll(newEdge.getSegments(lengthToTravel));
      getSegmentsUpToLength(newEdge, lengthToTravel - startEdge.getLength(), edges);
    }
  }
  
  @Override
  public VehicleState<O> update(VehicleState<O> previousState) {

    final VehicleState<O> updatedState =
        new VehicleState<O>(previousState);
    final MotionStateEstimatorPredictor motionStatePredictor =
        new MotionStateEstimatorPredictor(updatedState, this.random,
            (double) this.parameters.getInitialObsFreq());

    /*
     * Predict new location, i.e. project forward
     */
    final MultivariateGaussian predictedMotionState =
        motionStatePredictor
            .createPredictiveDistribution(updatedState
                .getMotionStateParam().getParameterPrior());
    /*
     * Add some transition error and set this as the
     * new motion state for our new vehicle state.
     */
    final Vector noisyPredictedState =
        motionStatePredictor.sampleStateTransDist(
            predictedMotionState.getMean(), this.random);
    predictedMotionState.setMean(noisyPredictedState);
    updatedState.getMotionStateParam().setParameterPrior(
        predictedMotionState);

    /*
     * We don't handle backward movement in this updater.
     */
    Preconditions.checkState(
        predictedMotionState.getInputDimensionality() == 4
            || predictedMotionState.getMean().getElement(0) >= 0d);
            
    PathEdge startEdge = updatedState.getPathStateParam().getValue().getEdge();
    
    final OnOffEdgeTransDistribution edgeTransDistribution =
        updatedState.getEdgeTransitionParam()
            .getConditionalDistribution();
    
    /*
     * We just use this edge as an indicator of whether we
     * go on or off road intially.  Once on or off is decided
     * we don't consider the change again.
     */
    InferenceGraphEdge initialEdge = edgeTransDistribution.sample(this.random);
    
    final Path newPath;
    if (initialEdge.isNullEdge()) {
      newPath = Path.nullPath;
    } else {
      if (startEdge.isNullEdge()) {
        /*
         * Going on-road from off-road
         */
        PathUtils.convertToRoadBelief(predictedMotionState, initialEdge, true);
        InferenceGraphSegment segment = Iterables.getLast(initialEdge.getSegments(predictedMotionState.getMean().getElement(0)));
        newPath = new Path(new PathEdge(segment, 0d, false));
        
      } else {
        final List<InferenceGraphSegment> edges = Lists.newArrayList();
        getSegmentsUpToLength(startEdge.getInferenceGraphEdge(), noisyPredictedState.getElement(0), edges);
        /*
         * Add the edge we started on, then create path edges for
         * the segments we sampled above.
         */
        List<PathEdge> pathEdges = Lists.newArrayList(new PathEdge(
            startEdge.getInferenceGraphEdge(), startEdge.getLine(), 0d, false));
        double distance = 0d;
        for (InferenceGraphSegment edge : edges) {
          pathEdges.add(new PathEdge(edge, distance + edge.getLine().getLength(), false));
        }
        newPath = new Path(pathEdges, false);
      }
    }

    final PathState newPathState =
        new PathState(newPath, predictedMotionState.getMean());

    updatedState.getPathStateParam().setValue(newPathState);
    updatedState.setParentState(previousState);

    return updatedState;
  }

  public void setRandom(Random rng) {
    this.random = rng;
  }

}