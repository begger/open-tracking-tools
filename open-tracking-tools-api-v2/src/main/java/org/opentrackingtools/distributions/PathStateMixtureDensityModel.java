package org.opentrackingtools.distributions;

import gov.sandia.cognition.math.RingAccumulator;
import gov.sandia.cognition.math.matrix.Vector;
import gov.sandia.cognition.math.matrix.VectorFactory;
import gov.sandia.cognition.statistics.ClosedFormComputableDistribution;
import gov.sandia.cognition.statistics.ProbabilityDensityFunction;
import gov.sandia.cognition.statistics.ProbabilityFunction;
import gov.sandia.cognition.statistics.distribution.DefaultDataDistribution;
import gov.sandia.cognition.statistics.distribution.LinearMixtureModel;
import gov.sandia.cognition.util.ObjectUtil;

import java.util.Arrays;
import java.util.Collection;
import java.util.Map;

import org.opentrackingtools.paths.PathEdge;
import org.opentrackingtools.paths.PathState;

import com.beust.jcommander.internal.Maps;

/**
 * Copy of MultivariateMixtureDensityModel for path states
 */
public class PathStateMixtureDensityModel<DistributionType extends ClosedFormComputableDistribution<PathState>>
    extends LinearMixtureModel<PathState, DistributionType> implements
    ClosedFormComputableDistribution<PathState> {

  /**
   * PDF of the MultivariateMixtureDensityModel
   * 
   * @param <DistributionType>
   *          Type of Distribution in the mixture
   */
  public static class PDF<DistributionType extends ClosedFormComputableDistribution<PathState>>
      extends PathStateMixtureDensityModel<DistributionType>
      implements ProbabilityDensityFunction<PathState> {

    private static final long serialVersionUID = -715039776358524176L;

    public PDF(Collection<? extends DistributionType> distributions) {
      super(distributions);
    }

    public PDF(Collection<? extends DistributionType> distributions,
      double[] priorWeights) {
      super(distributions, priorWeights);
    }

    public PDF(
      PathStateMixtureDensityModel<? extends DistributionType> other) {
      super(other);
    }

    public double[] computeRandomVariableLikelihoods(PathState input) {

      final int K = this.getDistributionCount();
      final double[] likelihoods = new double[K];
      for (int k = 0; k < K; k++) {
        final ProbabilityFunction<PathState> pdf =
            this.getDistributions().get(k).getProbabilityFunction();
        likelihoods[k] = pdf.evaluate(input);
      }

      return likelihoods;
    }

    /**
     * Computes the probability distribution that the input was generated by the
     * underlying distributions
     * 
     * @param input
     *          Input to consider
     * @return probability distribution that the input was generated by the
     *         underlying distributions
     */
    public double[]
        computeRandomVariableProbabilities(PathState input) {
      final int K = this.getDistributionCount();
      final double[] likelihoods =
          this.computeRandomVariableLikelihoods(input);
      double sum = 0.0;
      for (int k = 0; k < K; k++) {
        sum += likelihoods[k];
      }
      if (sum <= 0.0) {
        Arrays.fill(likelihoods, 1.0 / K);
      }

      sum = 0.0;
      for (int k = 0; k < K; k++) {
        likelihoods[k] *= this.priorWeights[k];
        sum += likelihoods[k];
      }
      if (sum <= 0.0) {
        Arrays.fill(likelihoods, 1.0 / K);
        sum = 1.0;
      }
      for (int k = 0; k < K; k++) {
        likelihoods[k] /= sum;
      }

      return likelihoods;

    }

    @Override
    public Double evaluate(PathState input) {
      double sum = 0.0;
      final int K = this.getDistributionCount();
      for (int k = 0; k < K; k++) {
        final ProbabilityFunction<PathState> pdf =
            this.getDistributions().get(k).getProbabilityFunction();
        sum += pdf.evaluate(input) * this.priorWeights[k];
      }

      return sum / this.getPriorWeightSum();
    }

    public int getMostLikelyRandomVariable(PathState input) {

      final double[] probabilities =
          this.computeRandomVariableProbabilities(input);
      int bestIndex = 0;
      double bestProbability = probabilities[0];
      for (int i = 1; i < probabilities.length; i++) {
        final double prob = probabilities[i];
        if (bestProbability < prob) {
          bestProbability = prob;
          bestIndex = i;
        }
      }

      return bestIndex;

    }

    @Override
    public PathStateMixtureDensityModel.PDF<DistributionType>
        getProbabilityFunction() {
      return this;
    }

    @Override
    public double logEvaluate(PathState input) {
      return Math.log(this.evaluate(input));
    }

  }

  private static final long serialVersionUID = 5143671580377145903L;

  public PathStateMixtureDensityModel(
    Collection<? extends DistributionType> distributions) {
    this(distributions, null);
  }

  public PathStateMixtureDensityModel(
    Collection<? extends DistributionType> distributions,
    double[] priorWeights) {
    super(distributions, priorWeights);
  }

  public PathStateMixtureDensityModel(
    PathStateMixtureDensityModel<? extends DistributionType> other) {
    this(ObjectUtil.cloneSmartElementsAsArrayList(other
        .getDistributions()), ObjectUtil.deepCopy(other
        .getPriorWeights()));
  }

  @Override
  public PathStateMixtureDensityModel<DistributionType> clone() {
    final PathStateMixtureDensityModel<DistributionType> clone =
        (PathStateMixtureDensityModel<DistributionType>) super
            .clone();
    return clone;
  }

  @Override
  public void convertFromVector(Vector parameters) {
    parameters
        .assertDimensionalityEquals(this.getDistributionCount());
    for (int k = 0; k < parameters.getDimensionality(); k++) {
      this.priorWeights[k] = parameters.getElement(k);
    }
  }

  @Override
  public Vector convertToVector() {
    return VectorFactory.getDefault().copyArray(
        this.getPriorWeights());
  }

  /**
   * Returns the first highest-probability path edge and its mean location, as a
   * path state, naturally.
   */
  @Override
  public PathState getMean() {

    final Map<PathEdge, RingAccumulator<Vector>> edgeToMean =
        Maps.newHashMap();
    final int K = this.getDistributionCount();
    final DefaultDataDistribution<PathEdge<?>> edgeDist =
        new DefaultDataDistribution<PathEdge<?>>();
    for (int k = 0; k < K; k++) {
      final double priorWeight = this.getPriorWeights()[k];
      final DistributionType dist = this.getDistributions().get(k);
      edgeDist.increment(dist.getMean().getEdge(), priorWeight);

      RingAccumulator<Vector> mean =
          edgeToMean.get(dist.getMean().getEdge());

      if (mean == null) {
        mean = new RingAccumulator<Vector>();
        edgeToMean.put(dist.getMean().getEdge(), mean);
      }
      mean.accumulate(dist.getMean().scale(priorWeight));
    }

    final PathEdge<?> bestEdge = edgeDist.getMaxValueKey();
    final RingAccumulator<Vector> mean = edgeToMean.get(bestEdge);
    return new PathState(bestEdge, mean.getSum().scale(
        1.0 / this.getPriorWeightSum()));

  }

  @Override
  public PathStateMixtureDensityModel.PDF<DistributionType>
      getProbabilityFunction() {
    return new PathStateMixtureDensityModel.PDF<DistributionType>(
        this);
  }

}
